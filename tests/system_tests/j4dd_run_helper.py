"""Run j4-dmenu-desktop with set environment and print good error messages."""

from __future__ import annotations

import os  # noqa: I001
import pathlib
import shlex
import subprocess
from dataclasses import dataclass
from typing import Callable, Iterable


class J4ddRunError(Exception):
    """J4-dmenu-desktop couldn't be executed/returned with nonzero exit status."""

    pass


def _assemble_to_reproduce_line(
    override_env: dict[str, str], args: Iterable[str]
) -> str:
    if len(override_env) == 0:
        reproducer = ""
    else:
        reproducer = " ".join(
            f"{key}={shlex.quote(value)}" for key, value in override_env.items()
        )
        reproducer += " "

    reproducer += shlex.join(args)
    return reproducer


def _assemble_error_message(
    stdout: str,
    stderr: str,
    override_env: dict[str, str],
    args: Iterable[str],
) -> str:
    """Assemble an informative error message about j4-dmenu-desktop execution.

    Error message generated by this function doesn't include the cause of the
    problem, they only describe the environment. Functions should prepend the
    error cause to the returned value.

    Args:
        stdout: stdout contents
        stderr: stderr contents
        override_env: overriden environment variables
        args: commandline executed

    Returns:
        Error message.
    """
    message = ""
    if stdout not in ("", "\n"):
        message += "".join(f"    {line}" for line in stdout.splitlines(keepends=True))

    message += "Stderr:\n"

    if stderr not in ("", "\n"):
        message += "".join(f"    {line}" for line in stderr.splitlines(keepends=True))

    message += "To reproduce:\n"
    message += f"    {_assemble_to_reproduce_line(override_env, args)}\n"

    return message


@dataclass
class _SubprocessRunResult:
    returncode: int
    stdout: str
    stderr: str


@dataclass
class _AsyncData:
    """A messanger class.

    This is a messanger class between _run_j4dd_impl, _subprocess_asynchronous
    run and AsyncJ4ddResult.
    """

    result: _SubprocessRunResult
    process: subprocess.Popen[str] | None = None


class AsyncJ4ddResult:
    """Result of run_j4dd() with asynchronous=True."""

    def __init__(
        self,
        async_data: _AsyncData,
        run_j4dd_impl_generator,
    ):
        """Internal initor.

        This initor should be only called by run_j4dd().
        """
        self._async_data = async_data
        self._run_j4dd_impl_generator = run_j4dd_impl_generator

    def wait(self, timeout: None | int | float = None) -> None:
        """Wait for j4-dmenu-desktop to finish.

        Arguments:
            timeout: timeout for the wait

        Raises:
            Same as run_j4dd().
        """
        assert self._async_data.process is not None

        process = self._async_data.process
        stdout, stderr = process.communicate(timeout=timeout)
        self._async_data.result.returncode = process.returncode
        self._async_data.result.stdout = stdout
        self._async_data.result.stderr = stderr
        next(self._run_j4dd_impl_generator, None)


def _subprocess_synchronous_run(
    args: list[str], env: dict[str, str]
) -> _SubprocessRunResult:
    result = subprocess.run(args, capture_output=True, text=True, env=env)
    return _SubprocessRunResult(result.returncode, result.stdout, result.stderr)


def _subprocess_asynchronous_run(
    async_data: _AsyncData, args: list[str], env: dict[str, str]
) -> _SubprocessRunResult:
    async_data.process = subprocess.Popen(
        args,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=env,
        text=True,
    )
    return async_data.result


def _run_j4dd_impl(
    subprocess_run: Callable[[list[str], dict[str, str]], _SubprocessRunResult],
    j4dd_executable_path: pathlib.Path,
    override_env: dict[str, str],
    *j4dd_arguments: str,
    shouldfail: bool = False,
):
    # This function doesn't accept j4dd_exe as str directly because having the
    # location as a pathlib.Path could be useful in the future (although it
    # isn't currently used in this implementation).
    j4dd_path_string = str(j4dd_executable_path)

    args: list[str]
    if "MESON_EXE_WRAPPER" in os.environ:
        args = (
            shlex.split(os.environ["MESON_EXE_WRAPPER"])
            + [j4dd_path_string]
            + list(j4dd_arguments)
        )
    else:
        args = [j4dd_path_string] + list(j4dd_arguments)

    env = os.environ.copy()
    for key, val in override_env.items():
        env[key] = val

    # Execute subprocess either synchronously or asynchronously
    try:
        result = subprocess_run(args, env)
    except OSError as exc:
        raise J4ddRunError(
            f"Couldn't execute j4-dmenu-desktop: {exc}\n"
            f"To reproduce:\n"
            f"    {_assemble_to_reproduce_line(override_env, args)}\n"
        ) from exc

    # Return execution to the caller temporarily (most useful in anync calls).
    yield
    if shouldfail:
        if result.returncode == 0:
            raise J4ddRunError(
                "j4-dmenu-desktop exitted with return code 0!\n"
                + _assemble_error_message(
                    result.stdout, result.stderr, override_env, args
                )
            )
    else:
        if result.returncode != 0:
            raise J4ddRunError(
                f"j4-dmenu-desktop exitted with return code "
                f"{result.returncode}!\n"
                + _assemble_error_message(
                    result.stdout, result.stderr, override_env, args
                )
            )


def run_j4dd(
    j4dd_executable_path: pathlib.Path,
    override_env: dict[str, str],
    *j4dd_arguments: str,
    shouldfail: bool = False,
    asynchronous: bool = False,
) -> None | AsyncJ4ddResult:
    """Run j4-dmenu-desktop.

    Args:
        j4dd_executable_path: path to j4-dmenu-desktop executable
        override_env: environment variables to override
        j4dd_arguments: arguments given to j4-dmenu-desktop
        shouldfail: should j4-dmenu-desktop fail? If yes, J4ddRunError will be
            raised if j4-dmenu-desktop exits with zero exit status.
        asynchronous: if true, do not wait for j4-dmenu-desktop to finish
            execution. If true, return an object that can be waited for later.

    Raises:
        J4ddRunErrorr: If j4-dmenu-desktop doesn't exit successfully.

    Returns:
        None if asynchronous is False,
    """
    if asynchronous:
        async_data = _AsyncData(_SubprocessRunResult(1000, "", ""))

        def async_run(*args):
            return _subprocess_asynchronous_run(async_data, *args)

        generator = _run_j4dd_impl(
            async_run,
            j4dd_executable_path,
            override_env,
            *j4dd_arguments,
            shouldfail=shouldfail,
        )
        next(generator)
        return AsyncJ4ddResult(async_data, generator)
    else:
        result = _run_j4dd_impl(
            _subprocess_synchronous_run,
            j4dd_executable_path,
            override_env,
            *j4dd_arguments,
            shouldfail=shouldfail,
        )
        next(result)
        next(result, None)
    return None
